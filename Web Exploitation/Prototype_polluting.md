# Cybersecurity (Web Exploitation)
Author: Kanishk Jagya  
GitHub: [github.com/KanishkJagya1](https://github.com/KanishkJagya1)

## Table of Contents
1. [Introduction](#introduction)
2. [Prototype Pollution](#prototype-pollution)
    - [Understanding Prototypes in JavaScript](#understanding-prototypes-in-javascript)
    - [Prototype Pollution in Action](#prototype-pollution-in-action)
    - [Example: Fruit Basket with Grass in It](#example-fruit-basket-with-grass-in-it)
    - [Admin Privileges Example](#admin-privileges-example)
    - [Exploiting via API Requests (Using Postman)](#exploiting-via-api-requests-using-postman)
    - [Preventing Prototype Pollution](#preventing-prototype-pollution)
    - [Example in a CTF Scenario](#example-in-a-ctf-scenario)
3. [Conclusion](#conclusion)

## Introduction
This repository provides a detailed explanation of Prototype Pollution, a common web security vulnerability, along with example code snippets and mitigation strategies. The content is particularly useful for Capture The Flag (CTF) challenges and practical web security.

## Prototype Pollution
Prototype pollution is a type of security vulnerability that specifically affects JavaScript applications. It occurs when an attacker is able to inject properties into the prototype of a base object, thereby affecting all objects that inherit from that prototype. This can lead to severe security issues, as it allows attackers to manipulate the behavior of applications.

### Understanding Prototypes in JavaScript
In JavaScript, objects inherit properties and methods from a prototype. Every JavaScript object has a prototype, which is also an object. When you create a new object, it automatically inherits properties and methods from its prototype.

### Prototype Pollution in Action
#### Example: Fruit Basket with Grass in It
Imagine you have a "FruitBasket" object in your application that holds information about different fruits. Here’s a simple example:

```javascript
let fruitBasket = {
    apple: 5,
    banana: 3,
    orange: 2
};
```

Now, suppose there’s a prototype object that defines some default behavior or properties for all fruit baskets:

```javascript
let prototype = {
    getTotalFruits: function() {
        return this.apple + this.banana + this.orange;
    }
};

Object.setPrototypeOf(fruitBasket, prototype);
```

#### The Attack
An attacker can exploit prototype pollution to add properties to the prototype object. For example, the attacker might add a `grass` property to the prototype, affecting all instances that inherit from this prototype:

```javascript
// Simulating prototype pollution
prototype.grass = 1;
```

Now, any `fruitBasket` that inherits from the prototype will have the `grass` property:

```javascript
console.log(fruitBasket.grass); // Output: 1
```

#### Admin Privileges Example
Consider a scenario where an application checks user roles based on object properties. Here’s a simple user object:

```javascript
let user = {
    role: 'user'
};
```

By polluting the prototype, an attacker can add an `isAdmin` property:

```javascript
let userPrototype = Object.getPrototypeOf(user);
userPrototype.isAdmin = true;
```

Now, all users will have the `isAdmin` property:

```javascript
console.log(user.isAdmin); // Output: true
```

This can be particularly dangerous if the application logic grants administrative privileges based on this property.

#### Exploiting via API Requests (Using Postman)
Attackers can exploit prototype pollution vulnerabilities through API requests. For example, consider an API endpoint that updates user information:

```javascript
// Vulnerable endpoint
app.post('/updateUser', (req, res) => {
    let user = getUserFromDatabase(req.body.userId);
    Object.assign(user, req.body);
    saveUserToDatabase(user);
    res.send('User updated');
});
```

An attacker can send a malicious request using Postman to pollute the prototype:

```json
{
    "__proto__": {
        "isAdmin": true
    }
}
```

This request would modify the prototype, making every user an admin:

```javascript
let attackerPayload = {
    "__proto__": {
        "isAdmin": true
    }
};

Object.assign(user, attackerPayload);

console.log(user.isAdmin); // Output: true
```

### Preventing Prototype Pollution
To protect against prototype pollution, consider the following best practices:

1. **Avoid Merging Untrusted Data**: Do not use functions like `Object.assign()` or deep merge utilities on objects containing user input without proper validation.
2. **Use Object.create(null)**: Create objects without prototypes if they are meant to be used as data structures for merging user inputs.
3. **Input Validation**: Implement strict input validation to ensure only expected properties are allowed.

### Example in a CTF Scenario
In a Capture The Flag (CTF) scenario, you might be given a web application with a feature that merges user input with existing objects. Your task would be to manipulate this feature to pollute the prototype, revealing the flag.

Here’s a step-by-step approach:
1. **Identify the Vulnerable Feature**: Look for functionalities that merge user input with existing objects.
2. **Craft a Malicious Payload**: Modify the input to add properties to the prototype (e.g., `{"__proto__": {"isAdmin": true}}`).
3. **Extract the Response**: Analyze the application behavior to extract sensitive information or the flag.

## Conclusion
Prototype pollution is a serious vulnerability in JavaScript applications that can have wide-ranging impacts. By understanding how prototypes work and how this type of attack can be executed, developers can better protect their applications from such vulnerabilities. Always validate and sanitize inputs, and be cautious when merging objects with user-supplied data.